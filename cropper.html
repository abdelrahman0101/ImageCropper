<!DOCTYPE html>
<html lang="">

<head>
    <meta charset="utf-8">
    <title>Image Cropper</title>
    <style>
        #cnvs {
            margin: 0;
            display: block;
            background-color: rgba(255, 255, 255, 0.7);
        }

        #cnvs_bg {
            border: 2px solid black;
        }

        #file_importer {
            display: none;
        }

        main {
            margin: auto;
            justify-content: center;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        #controls {
            display: flex;
            flex-direction: column;
            justify-content: center;
            width: 200px;
            gap: 10px;
        }

        .toolOptions,
        #toolButtons {
            display: none;
            flex-direction: column;
            justify-content: center;
            gap: 10px;
        }

        button {
            padding: 10px;
            cursor: pointer;
        }
    </style>
</head>

<body>
<header></header>
<main>
    <div id="cnvs_bg">
        <canvas width="400" height="300" id="cnvs"></canvas>
    </div>
    <div id="controls">
        <input type="file" id="file_importer" accept="image/*">
        <button id="btnUpload">Upload Image</button>
        <div id="toolButtons">
            <button id="btnCrop" class="tool">Crop</button>

        </div>
        <div id="cropTool" class="toolOptions">
            <label>Selection mode:</label>
            <label>
                <input type="radio" name="selection" value="rectangle" checked>
                Rectangle
            </label>
            <label>
                <input type="radio" name="selection" value="ellipse">
                Ellipse
            </label>
            <label>
                <input type="radio" name="selection" value="free">
                Free form
            </label>
            <button id="btnReset">Reset</button>
            <button id="btnSave">Save</button>
        </div>
    </div>
</main>
<footer></footer>
<script>
    function Path() { //path for free-form selection
        this.points = [];
        this.isOpen = false;
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
        this.addPoint = function (x, y) {
            this.points.push({x: x, y: y});
            this.minX = Math.min(this.minX, x);
            this.minY = Math.min(this.minY, y);
            this.maxX = Math.max(this.maxX, x);
            this.maxY = Math.max(this.maxY, y);
            //Close the path is the new point is too close to the start point
            this.isOpen = (Math.abs(x - this.points[0].x) > 5 || Math.abs(y - this.points[0].y) > 5);
        }
        this.getHeight = function () {
            return this.maxY - this.minY;
        }
        this.getWidth = function () {
            return this.maxX - this.minX;
        }
    }

    const EditMode = {
        // current status
        UploadImage: 0,
        Zoom: 1,
        Crop: 2,
    }

    let cnvs = document.querySelector("#cnvs");
    let ctx = cnvs.getContext("2d");
    ctx.setLineDash([5, 3]);
    ctx.strokeStyle = "blue";
    let img = null;  // to be loaded when an image is uploaded
    let status = EditMode.UploadImage;
    let drawing = false;
    let path = new Path(); //for free-form selection
    let start_point = null;
    let cropped_area = {x: 0, y: 0, w: cnvs.clientWidth, h: cnvs.clientHeight}; // selected area of the image
    let scaleRatio = 1;

    cnvs.addEventListener("pointerdown", (e) => {
        //console.log("Down at", e.clientX, e.clientY);
        if (status !== EditMode.Crop) {
            return;
        }
        let x = e.clientX - cnvs.getBoundingClientRect().left;
        let y = e.clientY - cnvs.getBoundingClientRect().top;
        ctx.globalCompositeOperation = "source-over"; //draw over existing content
        const cropMode = document.querySelector("input:checked").value;
        if (cropMode === "free") {
            if (!path.isOpen) {
                //starting a new selection path
                reloadImage();
                //draw a starting point (circle)
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.fillStyle = "white";
                ctx.fill();
                //open a new path
                ctx.beginPath();
                ctx.moveTo(x, y);
            } else {
                //draw a new segment
                ctx.lineTo(x, y);
                ctx.stroke();
            }
            path.addPoint(x, y);
        } else {
            clearSelection();
        }
        start_point = {x, y};
        drawing = true;
    });

    cnvs.addEventListener("pointermove", (e) => {
        //console.log("Moved at", e.clientX, e.clientY);
        if (drawing) {
            let x = e.clientX - cnvs.getBoundingClientRect().left;
            let y = e.clientY - cnvs.getBoundingClientRect().top;
            let cropMode = document.querySelector("input:checked").value;
            switch (cropMode) {
                case "free":
                    path.addPoint(x, y);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                    break;
                case "rectangle":
                    reloadImage();
                    ctx.beginPath();
                    ctx.rect(Math.min(x, start_point.x), Math.min(y, start_point.y),
                        Math.abs(x - start_point.x), Math.abs(y - start_point.y));
                    ctx.stroke();
                    break;
                case "ellipse":
                    reloadImage();
                    ctx.beginPath();
                    ctx.ellipse(start_point.x + (x - start_point.x) / 2, start_point.y + (y - start_point.y) / 2,
                        Math.abs(x - start_point.x) / 2, Math.abs(y - start_point.y) / 2,
                        0, 0, 2 * Math.PI);
                    ctx.stroke();
                    break;
            }
        }
    });

    cnvs.addEventListener("pointerup", (e) => {
        //console.log("Up at", e.clientX, e.clientY);
        if (!drawing)
            return;
        drawing = false;
        let x = e.clientX - cnvs.getBoundingClientRect().left;
        let y = e.clientY - cnvs.getBoundingClientRect().top;
        let cropMode = document.querySelector("input:checked").value;
        switch (cropMode) {
            case "free":
                cropped_area = {x: path.minX, y: path.minY, w: path.getWidth(), h: path.getHeight()};
                if (path.isOpen) {
                    return; //path is still open, continue adding segments
                }
                break;
            case "rectangle":
            case "ellipse":
                cropped_area = {
                    x: Math.min(x, start_point.x), y: Math.min(y, start_point.y),
                    w: Math.abs(x - start_point.x), h: Math.abs(y - start_point.y)
                };
                break;
        }
        finishCropping(cropMode);
    });

    function finishCropping(cropMode) {
        //reload image to erase selection path
        reloadImage();
        if (cropped_area.w < 20 || cropped_area.h < 20) {
            //too small area, probably a user mistake
            return;
        }
        ctx.beginPath(); //create a cropping boundary around the cropped area
        switch (cropMode) {
            case "free":
                ctx.moveTo(path.points[0].x, path.points[0].y);
                for (let p of path.points) {
                    ctx.lineTo(p.x, p.y);
                }
                path = new Path();
                break;
            case "rectangle":
                ctx.rect(cropped_area.x, cropped_area.y, cropped_area.w, cropped_area.h);
                break;
            case "ellipse":
                ctx.ellipse(cropped_area.x + cropped_area.w / 2, cropped_area.y + cropped_area.h / 2,
                    cropped_area.w / 2, cropped_area.h / 2,
                    0, 0, 2 * Math.PI);
                break;
        }
        //fill the boundary and keep only the intersection area of existing image
        ctx.globalCompositeOperation = "destination-in";
        ctx.fill();
    }

    function getScaleToFitRatio() {
        return Math.min((cnvs.clientWidth / img.width), (cnvs.clientHeight / img.height));
    }

    function reloadImage() {
        //redraw the uploaded image on the canvas
        if (img != null) {
            ctx.globalCompositeOperation = "source-over";
            ctx.clearRect(0, 0, cnvs.clientWidth, cnvs.clientHeight);
            ctx.drawImage(img, (cnvs.clientWidth - img.width * scaleRatio) / 2,
                (cnvs.clientHeight - img.height * scaleRatio) / 2,
                img.width * scaleRatio,
                img.height * scaleRatio
            );
        }
    }

    function setCanvasBackground() {
        //set the canvas container's background to the current image on the canvas
        //background image will appear behind the transparent pixels (bg color) after cropping
        document.querySelector("#cnvs_bg").style.background = "url('" + cnvs.toDataURL("image/png") + "')";
    }

    document.querySelector("#file_importer").addEventListener("change", (e) => {
        const file_url = e.target.files[0];
        const fileReader = new FileReader();
        fileReader.onload = function () {
            img = new Image;
            img.onload = function () {
                scaleRatio = getScaleToFitRatio();
                reloadImage();
                setCanvasBackground();
                img.onload = null;
                showTools();
            };
            img.src = fileReader.result;
        }
        fileReader.readAsDataURL(file_url);
    });

    function clearSelection() {
        reloadImage();
        path = new Path();
        cropped_area = {x: 0, y: 0, w: cnvs.clientWidth, h: cnvs.clientHeight};
        start_point = null;
        drawing = false;
    }

    document.querySelector("#cnvs").addEventListener("pointerout", () => {
        if (drawing)
            clearSelection();
    });

    document.querySelector("#cnvs").addEventListener("blur", () => {
        if (drawing)
            clearSelection();
    });

    document.querySelector("#btnReset").addEventListener("click", () => {
        clearSelection();
    });

    document.querySelector("#btnUpload").addEventListener("click", () => {
        document.querySelector("#file_importer").click();
    });

    document.querySelector("#btnCrop").addEventListener("click", () => {
        hideTools();
        document.querySelector("#cropTool").style.display = "flex";
        status = EditMode.Crop;
    });

    document.querySelector("#btnSave").addEventListener("click", () => {
        // save cropped image
        if (path.isOpen)
            finishCropping("free");
        let cropped = ctx.getImageData(cropped_area.x, cropped_area.y, cropped_area.w, cropped_area.h);
        let out_cnvs = document.createElement("canvas");
        out_cnvs.width = cropped_area.w;
        out_cnvs.height = cropped_area.h;
        out_cnvs.getContext("2d").putImageData(cropped, 0, 0);
        let downloadLink = document.createElement("a");
        let url = out_cnvs.toDataURL("image/png").replace(/^data:image\/[^;]/, 'data:application/octet-stream');
        downloadLink.setAttribute("download", Date.now().toString() + ".png");
        downloadLink.href = url
        downloadLink.click();
    });

    function showTools() {
        document.querySelector("#btnUpload").style.display = "none";
        document.querySelector("#toolButtons").style.display = "flex";
    }

    function hideTools() {
        document.querySelector("#toolButtons").style.display = "none";
    }

</script>
</body>

</html>